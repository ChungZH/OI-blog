{"pages":[],"posts":[{"title":"CF545D Queue","text":"题目链接https://www.luogu.org/problemnew/show/CF545D 题解还算简单的一道贪心题目。 当然也可以用队列来做。 题目就是 Queue 首先排序，然后用一个 time 变量记录所用总时间。如果这个人的等待的时间小于他被服务的时间，ans 就加 1 并且 time 加上这个人的服务时间。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int a[100005];long long ans, tim;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } sort(a, a+n); for (int i = 0; i &lt; n; i++) { if (tim &lt;= a[i]) { tim += a[i]; ans++; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/05/11/cf545d/"},{"title":"洛谷 P1162 填涂颜色","text":"题目链接https://www.luogu.org/problemnew/show/P1162 题解这道题有点意思，个人感觉比跳马和迷宫那两题都要难一点。 个人感觉 DFS 好写点，于是我就用了 DFS。 我的思路是这样的： 首先，$2$ 不可能出现在方阵边缘。因为闭合圈周围都要有数字 $1$。 所以我们先遍历方阵的四条边，用 DFS 先把闭合圈外面所有的 $0$ 改成 $2$。 这样方阵就会有三种数字：$0$、$1$、$2$。 其中，$0$ 表示在闭合圈内，$1$ 表示是闭合圈的边缘，$2$ 表示在闭合圈外。 比如下面这个样例： 1234560 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1 经过如上处理后，就会变成这样： 1234562 2 2 2 2 22 2 1 1 1 12 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1 所以我们只要这样输出： 如果是 $2$，就输出 $0$ 如果是 $1$，就输出 $1$ 如果是 $0$，就输出 $2$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int n;int a[35][35];const int dx[] {-1, 1, 0, 0}, dy[] {0, 0, -1, 1};void dfs(int x, int y);int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; a[i][j]; } } for (int j = 1; j &lt;= n; j++) { if (a[1][j] == 0) { dfs(1, j); } if (a[n][j] == 0) { dfs(n, j); } } for (int i = 1; i &lt;= n; i++) { if (a[i][1] == 0) { dfs(i, 1); } if (a[i][n] == 0) { dfs(i, n); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (a[i][j] == 2) cout &lt;&lt; 0 &lt;&lt; ' '; else if (a[i][j] == 0) cout &lt;&lt; 2 &lt;&lt; ' '; else cout &lt;&lt; 1 &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0;}void dfs(int x, int y){ if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n || a[x][y] != 0) { return; } else { a[x][y] = 2; } for (int i = 0; i &lt; 4; i++) { int tx = x+dx[i]; int ty = y+dy[i]; dfs(tx, ty); }}","link":"/2019/05/04/luogu1162/"},{"title":"洛谷 P1443 马的遍历","text":"题目链接题解","link":"/2019/05/18/luogu1443/"},{"title":"洛谷 P1464 Function","text":"题目链接题解","link":"/2019/05/18/luogu1464/"},{"title":"洛谷 P1605 迷宫","text":"题目链接https://www.luogu.org/problemnew/show/P1605 题解就是一道 DFS，不过坑有点多。 一道 普及- 的题目提交了 3 次才 A 掉，还是太弱了…… 坑点总结： 起点不是 1, 1，而是数据中的 sx, sy。 记得要把起点设为已经访问！！！我就因为这个一直没 AC，看了看题解才意识到这个坑。。。 其它的就没什么了，DFS 打熟练了都会写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;void dfs(int x, int y);int ans, n, m, t;int sx, sy, fx, fy;int a[10][10];bool book[10][10];const int dx[4] {-1, 1, 0, 0}, dy[4] {0, 0, -1, 1};int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy; for (int i = 0; i &lt; t; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; a[x][y] = -1; } book[sx][sy] = 1; dfs(sx, sy); cout &lt;&lt; ans &lt;&lt; endl; return 0;}void dfs(int x, int y){ if (x == fx &amp;&amp; y == fy) { ans++; return; } for (int i = 0; i &lt; 4; i++) { int tx = x+dx[i], ty = y+dy[i]; if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m) continue; if (book[tx][ty] == 0 &amp;&amp; a[tx][ty] != -1 &amp;&amp; tx &lt;= n &amp;&amp; tx &gt;= 1) { book[tx][ty] = 1; dfs(tx, ty); book[tx][ty] = 0; } }}","link":"/2019/05/04/luogu1605/"},{"title":"洛谷 P1644 跳马问题","text":"题目链接https://www.luogu.org/problemnew/show/P1644 题解还是不太难的 DFS。 虽说马可以有 8 种跳法，但是这里题目 规定只能往右跳，也就只有 4 个跳法了。 下面代码中的 dx 和 dy 数组就是马的走法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int ans, n, m;const int dx[] { 2, 1, -1, -2}, dy[] { 1, 2, 2, 1};void dfs(int x, int y);int main(){ cin &gt;&gt; n &gt;&gt; m; dfs(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;}void dfs(int x, int y){ if (x == n &amp;&amp; y == m) { ans++; return ; } if (x &lt; 0 || y &lt; 0 || x &gt; n || y &gt; m) return; // 判断是否越界 for (int i = 0; i &lt; 4; i++) { dfs(x + dx[i], y + dy[i]); }}","link":"/2019/05/04/luogu1644/"},{"title":"洛谷 P1765 手机_NOI导刊2010普及（10）","text":"题目链接题解","link":"/2019/05/18/luogu1765/"},{"title":"洛谷 P1958 上学路线_NOI导刊2009普及（6）","text":"题目链接题解","link":"/2019/05/18/luogu1958/"},{"title":"洛谷 P1969 积木大赛","text":"题目链接题解","link":"/2019/05/18/luogu1969/"},{"title":"AT2412 最大の和","text":"题目链接https://www.luogu.org/problemnew/show/AT2412 题解其实是一道很简单的题，个人感觉难度 普及-，就是一道前缀和题目。 不知道前缀和的话可以看这里 前缀和 - OI Wiki。 用 b 数组作为前缀和数组，然后算 b 中 最大的长度为 k 的区间的和。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int a[100001], b[100001];int main(){ int n, k, maxx = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } b[1] = a[1]; for (int i = 2; i &lt;= n; i++) { b[i] = b[i-1] + a[i]; } for (int i = k; i &lt;= n; i++) { if (b[i] - b[i-k] &gt; maxx) maxx = b[i] - b[i-k]; } cout &lt;&lt; maxx &lt;&lt; endl; return 0;}","link":"/2019/05/18/at2412/"},{"title":"洛谷 P2615 神奇的幻方","text":"题目链接题解","link":"/2019/05/18/luogu2615/"},{"title":"洛谷 P3984 高兴的津津","text":"","link":"/2019/05/18/luogu3984/"},{"title":"洛谷 P4431 [COCI2017-2018#2] ​Košnja","text":"题目链接题解","link":"/2019/05/18/luogu4431/"}],"tags":[{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"连通块","slug":"连通块","link":"/tags/连通块/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"}]}