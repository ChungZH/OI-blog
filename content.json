{"pages":[],"posts":[{"title":"AT2412 最大の和","text":"题目链接https://www.luogu.org/problemnew/show/AT2412 题解其实是一道很简单的题，个人感觉难度 普及-，就是一道前缀和题目。 不知道前缀和的话可以看这里 前缀和 - OI Wiki。 用 b 数组作为前缀和数组，然后算 b 中 最大的长度为 k 的区间的和。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int a[100001], b[100001];int main(){ int n, k, maxx = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } b[1] = a[1]; for (int i = 2; i &lt;= n; i++) { b[i] = b[i-1] + a[i]; } for (int i = k; i &lt;= n; i++) { if (b[i] - b[i-k] &gt; maxx) maxx = b[i] - b[i-k]; } cout &lt;&lt; maxx &lt;&lt; endl; return 0;}","link":"/2019/05/18/at2412/"},{"title":"CF545D Queue","text":"题目链接https://www.luogu.org/problemnew/show/CF545D 题解还算简单的一道贪心题目。 当然也可以用队列来做。 题目就是 Queue 首先排序，然后用一个 time 变量记录所用总时间。如果这个人的等待的时间小于他被服务的时间，ans 就加 1 并且 time 加上这个人的服务时间。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int a[100005];long long ans, tim;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } sort(a, a+n); for (int i = 0; i &lt; n; i++) { if (tim &lt;= a[i]) { tim += a[i]; ans++; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/05/11/cf545d/"},{"title":"洛谷 P1162 填涂颜色","text":"题目链接https://www.luogu.org/problemnew/show/P1162 题解这道题有点意思，个人感觉比跳马和迷宫那两题都要难一点。 我觉得 DFS 好写点，于是就用了 DFS。 思路是这样的： 首先，$2$ 不可能出现在方阵边缘。因为闭合圈周围都要有数字 $1$。 所以我们先遍历方阵的四条边，用 DFS 先把闭合圈外面所有的 $0$ 改成 $2$。 这样方阵就会有三种数字：$0$、$1$、$2$。 其中，$0$ 表示在闭合圈内，$1$ 表示是闭合圈的边缘，$2$ 表示在闭合圈外。 比如下面这个样例： 1234560 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1 经过如上处理后，就会变成这样： 1234562 2 2 2 2 22 2 1 1 1 12 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1 所以我们只要这样输出： 如果是 $2$，就输出 $0$ 如果是 $1$，就输出 $1$ 如果是 $0$，就输出 $2$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int n;int a[35][35];const int dx[] {-1, 1, 0, 0}, dy[] {0, 0, -1, 1};void dfs(int x, int y);int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; a[i][j]; } } for (int j = 1; j &lt;= n; j++) { if (a[1][j] == 0) { dfs(1, j); } if (a[n][j] == 0) { dfs(n, j); } } for (int i = 1; i &lt;= n; i++) { if (a[i][1] == 0) { dfs(i, 1); } if (a[i][n] == 0) { dfs(i, n); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (a[i][j] == 2) cout &lt;&lt; 0 &lt;&lt; ' '; else if (a[i][j] == 0) cout &lt;&lt; 2 &lt;&lt; ' '; else cout &lt;&lt; 1 &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0;}void dfs(int x, int y){ if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n || a[x][y] != 0) { return; } else { a[x][y] = 2; } for (int i = 0; i &lt; 4; i++) { int tx = x+dx[i]; int ty = y+dy[i]; dfs(tx, ty); }}","link":"/2019/05/04/luogu1162/"},{"title":"洛谷 P1443 马的遍历","text":"题目链接题解","link":"/2019/05/27/luogu1443/"},{"title":"洛谷 P1464 Function","text":"题目链接题解","link":"/2019/05/27/luogu1464/"},{"title":"洛谷 P1605 迷宫","text":"题目链接https://www.luogu.org/problemnew/show/P1605 题解就是一道 DFS，不过坑有点多。 一道 普及- 的题目提交了 3 次才 A 掉，还是太弱了…… 坑点总结： 起点不是 1, 1，而是数据中的 sx, sy。 记得要把起点设为已经访问！！！我就因为这个一直没 AC，看了看题解才意识到这个坑。。。 其它的就没什么了，DFS 打熟练了都会写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;void dfs(int x, int y);int ans, n, m, t;int sx, sy, fx, fy;int a[10][10];bool book[10][10];const int dx[4] {-1, 1, 0, 0}, dy[4] {0, 0, -1, 1};int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy; for (int i = 0; i &lt; t; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; a[x][y] = -1; } book[sx][sy] = 1; dfs(sx, sy); cout &lt;&lt; ans &lt;&lt; endl; return 0;}void dfs(int x, int y){ if (x == fx &amp;&amp; y == fy) { ans++; return; } for (int i = 0; i &lt; 4; i++) { int tx = x+dx[i], ty = y+dy[i]; if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m) continue; if (book[tx][ty] == 0 &amp;&amp; a[tx][ty] != -1 &amp;&amp; tx &lt;= n &amp;&amp; tx &gt;= 1) { book[tx][ty] = 1; dfs(tx, ty); book[tx][ty] = 0; } }}","link":"/2019/05/04/luogu1605/"},{"title":"洛谷 P1644 跳马问题","text":"题目链接https://www.luogu.org/problemnew/show/P1644 题解还是不太难的 DFS。 虽说马可以有 8 种跳法，但是这里题目 规定只能往右跳，也就只有 4 个跳法了。 下面代码中的 dx 和 dy 数组就是马的走法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int ans, n, m;const int dx[] { 2, 1, -1, -2}, dy[] { 1, 2, 2, 1};void dfs(int x, int y);int main(){ cin &gt;&gt; n &gt;&gt; m; dfs(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;}void dfs(int x, int y){ if (x == n &amp;&amp; y == m) { ans++; return ; } if (x &lt; 0 || y &lt; 0 || x &gt; n || y &gt; m) return; // 判断是否越界 for (int i = 0; i &lt; 4; i++) { dfs(x + dx[i], y + dy[i]); }}","link":"/2019/05/04/luogu1644/"},{"title":"洛谷 P1724 东风谷早苗","text":"题目链接https://www.luogu.org/problemnew/show/P1724 题解最近在洛谷上发现了这题，突然一阵熟悉的感觉… 原来是 NHOI 模拟赛 里面的题目！！！ 怪不得呢。。。这波操作也是够 6，直接把网上的题目的背景改一下就放进自己的比赛里。。。 哦对了，还有 这题 也是被同样的一波操作给弄进模拟赛了。。 其实很简单的一道题，模拟赛的时候就没拿满分。考完之后重新做一次就 A 了。 刚开始想得很简单，觉得直接模拟就可以了。（弄过来的时候数据范围也没写一写，导致了我产生这个错误的思路，差评） 后来直接模拟没满分，就改了一个麻烦点的做法。 分类讨论： T &lt; 命令串长度：直接模拟没毛病！ T &gt;= 命令串长度：先模拟一次执行一遍命令串后，x 和 y 会是多少。然后乘 T / 命令串长度 ，如果还有余就再模拟一下。 这样一来，速度就上去了。 还有，其实下面的代码里面其实是可以大大简化的，把模拟命令的那部分写成一个函数的话可以大大减少代码长度。由于懒就没写成函数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;int main(){ std::string s; std::cin &gt;&gt; s; long long T; std::cin &gt;&gt; T; long long x, y, tx, ty; x = y = tx = ty = 0; if (T &lt; s.length()) { for (int i = 0; i &lt; T; i++) { switch (s[i]) { case 'E': x++; break; case 'S': y--; break; case 'W': x--; break; case 'N': y++; break; default: break; } } std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; std::endl; } else { for (int i = 0; i &lt; s.length(); i++) { switch (s[i]) { case 'E': tx++; break; case 'S': ty--; break; case 'W': tx--; break; case 'N': ty++; break; default: break; } } int temp = T / s.length(); x += temp * tx; y += temp * ty; if (T % s.length() != 0) { for (int i = 0; i &lt; T % s.length(); i++) { switch (s[i]) { case 'E': x++; break; case 'S': y--; break; case 'W': x--; break; case 'N': y++; break; default: break; } } } std::cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; std::endl; } return 0;}","link":"/2019/05/27/luogu1724/"},{"title":"洛谷 P1765 手机_NOI导刊2010普及（10）","text":"题目链接题解","link":"/2019/05/27/luogu1765/"},{"title":"洛谷 P1958 上学路线_NOI导刊2009普及（6）","text":"题目链接题解","link":"/2019/05/27/luogu1958/"},{"title":"洛谷 P1969 积木大赛","text":"题目链接题解","link":"/2019/05/27/luogu1969/"},{"title":"洛谷 P2615 神奇的幻方","text":"题目链接题解","link":"/2019/05/27/luogu2615/"},{"title":"洛谷 P3984 高兴的津津","text":"题目链接https://www.luogu.org/problemnew/show/P3984 题解很简单的啦。 被 NHOI 一顿神操作给弄进了模拟赛，一模一样的。。。 sum：累计开心的天数 sta：上一次开始开心的时候 首先 sum = T，sta = a[0]。 如果上次开心还没结束，a[i] 就来了，sum 就加上 a[i] 减去 sta。 否则就 sum + T，sta = a[i]。 拿样例试一下： 123 51 2 10 ok，现在循环没开始，T 是 5，sum = T，sta = a[0]。 循环开始了，i=1，a[i] 是 2，sta 是 1，2 &lt; 1 + 5 这个条件成立，所以 sum += 2 - 1，sta = 2。 i=2，a[i] 是 10，sta 是 2，10 &lt; 2 + 5 这个条件不成立，所以 sum += 5，sta = a[i]。 最后输出 sum 即可。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int N, T, sum = 0, sta = 0; cin &gt;&gt; N &gt;&gt; T; int a[200002]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; sum = T; sta = a[0]; for (int i = 1; i &lt; N; i++) { if (a[i] &lt; sta + T) { sum += a[i] - sta; sta = a[i]; } else { sum += T; sta = a[i]; } } cout &lt;&lt; sum &lt;&lt; endl; return 0;}","link":"/2019/05/27/luogu3984/"},{"title":"洛谷 P4431 [COCI2017-2018#2] ​Košnja","text":"题目链接题解","link":"/2019/05/27/luogu4431/"}],"tags":[{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"连通块","slug":"连通块","link":"/tags/连通块/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"周期","slug":"周期","link":"/tags/周期/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"}]}