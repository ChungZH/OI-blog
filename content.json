{"pages":[],"posts":[{"title":"AT2412 最大の和","text":"题目链接https://www.luogu.org/problemnew/show/AT2412 题解其实是一道很简单的题，个人感觉难度 普及-，就是一道前缀和题目。 不知道前缀和的话可以看这里 前缀和 - OI Wiki。 用 b 数组作为前缀和数组，然后算 b 中 最大的长度为 k 的区间的和。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int a[100001], b[100001];int main(){ int n, k, maxx = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } b[1] = a[1]; for (int i = 2; i &lt;= n; i++) { b[i] = b[i-1] + a[i]; } for (int i = k; i &lt;= n; i++) { if (b[i] - b[i-k] &gt; maxx) maxx = b[i] - b[i-k]; } cout &lt;&lt; maxx &lt;&lt; endl; return 0;}","link":"/2019/05/18/at2412/"},{"title":"CF545D Queue","text":"题目链接https://www.luogu.org/problemnew/show/CF545D 题解还算简单的一道贪心题目。 当然也可以用队列来做。 题目就是 Queue 首先排序，然后用一个 time 变量记录所用总时间。如果这个人的等待的时间小于他被服务的时间，ans 就加 1 并且 time 加上这个人的服务时间。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int a[100005];long long ans, tim;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } sort(a, a+n); for (int i = 0; i &lt; n; i++) { if (tim &lt;= a[i]) { tim += a[i]; ans++; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/05/11/cf545d/"},{"title":"洛谷 P1162 填涂颜色","text":"题目链接https://www.luogu.org/problemnew/show/P1162 题解这道题有点意思，个人感觉比跳马和迷宫那两题都要难一点。 我觉得 DFS 好写点，于是就用了 DFS。 思路是这样的： 首先，$2$ 不可能出现在方阵边缘。因为闭合圈周围都要有数字 $1$。 所以我们先遍历方阵的四条边，用 DFS 先把闭合圈外面所有的 $0$ 改成 $2$。 这样方阵就会有三种数字：$0$、$1$、$2$。 其中，$0$ 表示在闭合圈内，$1$ 表示是闭合圈的边缘，$2$ 表示在闭合圈外。 比如下面这个样例： 1234560 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1 经过如上处理后，就会变成这样： 1234562 2 2 2 2 22 2 1 1 1 12 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1 所以我们只要这样输出： 如果是 $2$，就输出 $0$ 如果是 $1$，就输出 $1$ 如果是 $0$，就输出 $2$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int n;int a[35][35];const int dx[] {-1, 1, 0, 0}, dy[] {0, 0, -1, 1};void dfs(int x, int y);int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; a[i][j]; } } for (int j = 1; j &lt;= n; j++) { if (a[1][j] == 0) { dfs(1, j); } if (a[n][j] == 0) { dfs(n, j); } } for (int i = 1; i &lt;= n; i++) { if (a[i][1] == 0) { dfs(i, 1); } if (a[i][n] == 0) { dfs(i, n); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (a[i][j] == 2) cout &lt;&lt; 0 &lt;&lt; ' '; else if (a[i][j] == 0) cout &lt;&lt; 2 &lt;&lt; ' '; else cout &lt;&lt; 1 &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0;}void dfs(int x, int y){ if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n || a[x][y] != 0) { return; } else { a[x][y] = 2; } for (int i = 0; i &lt; 4; i++) { int tx = x+dx[i]; int ty = y+dy[i]; dfs(tx, ty); }}","link":"/2019/05/04/luogu1162/"},{"title":"洛谷 P1443 马的遍历","text":"题目链接题解","link":"/2019/06/01/luogu1443/"},{"title":"洛谷 P1464 Function","text":"题目链接题解","link":"/2019/06/01/luogu1464/"},{"title":"洛谷 P1605 迷宫","text":"题目链接https://www.luogu.org/problemnew/show/P1605 题解就是一道 DFS，不过坑有点多。 一道 普及- 的题目提交了 3 次才 A 掉，还是太弱了…… 坑点总结： 起点不是 1, 1，而是数据中的 sx, sy。 记得要把起点设为已经访问！！！我就因为这个一直没 AC，看了看题解才意识到这个坑。。。 其它的就没什么了，DFS 打熟练了都会写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;void dfs(int x, int y);int ans, n, m, t;int sx, sy, fx, fy;int a[10][10];bool book[10][10];const int dx[4] {-1, 1, 0, 0}, dy[4] {0, 0, -1, 1};int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy; for (int i = 0; i &lt; t; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; a[x][y] = -1; } book[sx][sy] = 1; dfs(sx, sy); cout &lt;&lt; ans &lt;&lt; endl; return 0;}void dfs(int x, int y){ if (x == fx &amp;&amp; y == fy) { ans++; return; } for (int i = 0; i &lt; 4; i++) { int tx = x+dx[i], ty = y+dy[i]; if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m) continue; if (book[tx][ty] == 0 &amp;&amp; a[tx][ty] != -1 &amp;&amp; tx &lt;= n &amp;&amp; tx &gt;= 1) { book[tx][ty] = 1; dfs(tx, ty); book[tx][ty] = 0; } }}","link":"/2019/05/04/luogu1605/"},{"title":"洛谷 P1644 跳马问题","text":"题目链接https://www.luogu.org/problemnew/show/P1644 题解还是不太难的 DFS。 虽说马可以有 8 种跳法，但是这里题目 规定只能往右跳，也就只有 4 个跳法了。 下面代码中的 dx 和 dy 数组就是马的走法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int ans, n, m;const int dx[] { 2, 1, -1, -2}, dy[] { 1, 2, 2, 1};void dfs(int x, int y);int main(){ cin &gt;&gt; n &gt;&gt; m; dfs(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;}void dfs(int x, int y){ if (x == n &amp;&amp; y == m) { ans++; return ; } if (x &lt; 0 || y &lt; 0 || x &gt; n || y &gt; m) return; // 判断是否越界 for (int i = 0; i &lt; 4; i++) { dfs(x + dx[i], y + dy[i]); }}","link":"/2019/05/04/luogu1644/"},{"title":"洛谷 P1724 东风谷早苗","text":"题目链接https://www.luogu.org/problemnew/show/P1724 题解最近在洛谷上发现了这题，突然一阵熟悉的感觉… 原来是 NHOI 模拟赛 里面的题目！！！ 怪不得呢。。。这波操作也是够 6，直接把网上的题目的背景改一下就放进自己的比赛里。。。 哦对了，还有 这题 也是被同样的一波操作给弄进模拟赛了。。 其实很简单的一道题，模拟赛的时候就没拿满分。考完之后重新做一次就 A 了。 刚开始想得很简单，觉得直接模拟就可以了。（弄过来的时候数据范围也没写一写，导致了我产生这个错误的思路，差评） 后来直接模拟没满分，就改了一个麻烦点的做法。 分类讨论： T &lt; 命令串长度：直接模拟没毛病！ T &gt;= 命令串长度：先模拟一次执行一遍命令串后，x 和 y 会是多少。然后乘 T / 命令串长度 ，如果还有余就再模拟一下。 这样一来，速度就上去了。 还有，其实下面的代码里面其实是可以大大简化的，把模拟命令的那部分写成一个函数的话可以大大减少代码长度。由于懒就没写成函数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;int main(){ std::string s; std::cin &gt;&gt; s; long long T; std::cin &gt;&gt; T; long long x, y, tx, ty; x = y = tx = ty = 0; if (T &lt; s.length()) { for (int i = 0; i &lt; T; i++) { switch (s[i]) { case 'E': x++; break; case 'S': y--; break; case 'W': x--; break; case 'N': y++; break; default: break; } } std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; std::endl; } else { for (int i = 0; i &lt; s.length(); i++) { switch (s[i]) { case 'E': tx++; break; case 'S': ty--; break; case 'W': tx--; break; case 'N': ty++; break; default: break; } } int temp = T / s.length(); x += temp * tx; y += temp * ty; if (T % s.length() != 0) { for (int i = 0; i &lt; T % s.length(); i++) { switch (s[i]) { case 'E': x++; break; case 'S': y--; break; case 'W': x--; break; case 'N': y++; break; default: break; } } } std::cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; std::endl; } return 0;}","link":"/2019/05/27/luogu1724/"},{"title":"洛谷 P1765 手机_NOI导刊2010普及（10）","text":"题目链接题解","link":"/2019/06/01/luogu1765/"},{"title":"洛谷 P1958 上学路线_NOI导刊2009普及（6）","text":"题目链接https://www.luogu.org/problemnew/show/P1958 题解dp DFS 都可以吧。 flag 是标记可不可以通行。 由于只能往东和北走，所以一个地方的走法数量就是它 西（左）边走法之和 加 南（下）边走法之和。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int a, b, n, ans;bool flag[50][50];int dp[50][50]; int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; int x, y; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x &gt;&gt; y; flag[x][y] = true; } dp[1][1] = 1; for (int i = 1; i &lt;= a; i++) { for (int j = 1; j &lt;= b; j++) { if (i == 1 &amp;&amp; j == 1 || flag[i][j] == true) continue; dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } cout &lt;&lt; dp[a][b] &lt;&lt; endl; return 0;}","link":"/2019/06/01/luogu1958/"},{"title":"洛谷 P1969 积木大赛","text":"题目链接https://www.luogu.org/problemnew/solution/P1969 题解now 就是当前高度，ans 就是答案。 now 就是当前高度，ans 就是答案。 首先 now = ans = a[0] 就是怎么样最少至少都会操作 a[0] 次。 然后一个一个看，如果大于 now，ans += a[i] - now 也就是增加操作次数，now = a[i] 更新当前高度。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;long long n, now, ans;long long a[1000000];int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } now = ans = a[0]; for (int i = 1; i &lt; n; i++) { if (a[i] &gt; now) { ans += a[i] - now; } now = a[i]; } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","link":"/2019/06/01/luogu1969/"},{"title":"洛谷 P2615 神奇的幻方","text":"题目链接https://www.luogu.org/problemnew/show/P2615 题解其实很简单嘛，模拟就好啦。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std;int a[45][45] = { 0 };int main(){ int n; int k, prevX, prevY; cin &gt;&gt; n; a[1][n/2+1] = 1; // 首先将 1 放在第一行中间 k = 1; prevX = 1, prevY = n/2+1; k++; while (k &lt;= n*n) { if (prevX == 1 &amp;&amp; prevY != n) { a[prevX = n][++prevY] = k++; } else if (prevY == n &amp;&amp; prevX != 1) { a[--prevX][prevY = 1] = k++; } else if (prevX == 1 &amp;&amp; prevY == n) { a[++prevX][prevY] = k++; } else if (prevX != 1 &amp;&amp; prevY != n) { if (a[prevX-1][prevY+1] == 0) { a[--prevX][++prevY] = k++; } else { a[++prevX][prevY] = k++; } } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cout &lt;&lt; a[i][j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0;}","link":"/2019/06/01/luogu2615/"},{"title":"洛谷 P3984 高兴的津津","text":"题目链接https://www.luogu.org/problemnew/show/P3984 题解很简单的啦。 被 NHOI 一顿神操作给弄进了模拟赛，一模一样的。。。 sum：累计开心的天数 sta：上一次开始开心的时候 首先 sum = T，sta = a[0]。 如果上次开心还没结束，a[i] 就来了，sum 就加上 a[i] 减去 sta。 否则就 sum + T，sta = a[i]。 拿样例试一下： 123 51 2 10 ok，现在循环没开始，T 是 5，sum = T，sta = a[0]。 循环开始了，i=1，a[i] 是 2，sta 是 1，2 &lt; 1 + 5 这个条件成立，所以 sum += 2 - 1，sta = 2。 i=2，a[i] 是 10，sta 是 2，10 &lt; 2 + 5 这个条件不成立，所以 sum += 5，sta = a[i]。 最后输出 sum 即可。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int N, T, sum = 0, sta = 0; cin &gt;&gt; N &gt;&gt; T; int a[200002]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; sum = T; sta = a[0]; for (int i = 1; i &lt; N; i++) { if (a[i] &lt; sta + T) { sum += a[i] - sta; sta = a[i]; } else { sum += T; sta = a[i]; } } cout &lt;&lt; sum &lt;&lt; endl; return 0;}","link":"/2019/05/27/luogu3984/"},{"title":"洛谷 P4305 [JLOI2011]不重复数字","text":"题目链接https://www.luogu.org/problemnew/show/P4305 题解一看题目里面 去重 我就想到了桶排序，不过这道题不是完全的桶排序，只是用到 桶 但是不用 排序。 虽然数字比较大，但是不用遍历桶数组，速度也不是问题。 其实很简单，开一个 bool 类型的桶数组（不需要 int），然后如果有出现的数字就标 true，否则 false。 最后输出，如果桶里面这个数是 true，就直接输出然后标 false。如果是 false 就不输出。这样就可以去重了。 （后来发现题解里也有一个思路一样的，不过他的代码要比我的更优秀点。） 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool bucket[10000005];int a[50005];int main(){ int T; scanf(\"%d\", &amp;T); while (T --&gt; 0) { int n; scanf(\"%d\", &amp;n); // 下面一行其实是可以不用的，看到题解才恍然大悟：bucket 数组在输出的时候已经被全部标成 0 了！ memset(bucket, 0, sizeof(bucket)); // memset(a, 0, sizeof(a)); // 无必要 for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;a[i]); bucket[a[i]] = 1; } for (int i = 0; i &lt; n; i++) { if (bucket[a[i]] == 1) { printf(\"%d \", a[i]); bucket[a[i]] = 0; } } putchar('\\n'); } return 0;}","link":"/2019/06/01/luogu4305/"},{"title":"洛谷 P4431 [COCI2017-2018#2] Košnja","text":"题目链接https://www.luogu.org/problemnew/show/P4431 题解看上去就很简单，实际上更简单。 刚刚看的时候，觉得一个搜索就 OK 了。 然后又转念一想，又发现了一个规律。 答案就是 (min(n, m)-1)*2。 也就是 (行和列中较小的那个数-1)*2，手推一下就好了。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main(){ int k; scanf(\"%d\", &amp;k); while (k--) { int n, m; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", (min(n, m)-1)*2); } return 0;}","link":"/2019/06/01/luogu4431/"}],"tags":[{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"连通块","slug":"连通块","link":"/tags/连通块/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"周期","slug":"周期","link":"/tags/周期/"},{"name":"递推","slug":"递推","link":"/tags/递推/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"桶排序思想","slug":"桶排序思想","link":"/tags/桶排序思想/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"找规律","slug":"找规律","link":"/tags/找规律/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"}]}