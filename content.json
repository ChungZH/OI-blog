{"pages":[],"posts":[{"title":"NHOI 2019 游记","text":"NHOI：南海区青少年信息学竞赛。 Day -1日常颓废，用心思考如何提高人品。希望能拿到前 50 名。 上次是五十开外，总要有点进步才行啊。 不过要去到好的中学，五十名内可能也还不够吧。。 不管怎样，努力吧，不想留下遗憾！ Day 1今天很早就起床了。早上吃了一根香肠和一个荷包蛋，很香。状态也很好。 进考场之后开始颓废小恐龙。。。 对了，监考老师有一个很漂亮的小姐姐。。。 本来还想睡一会儿觉，最后还是忍不住两边赛友的小恐龙的诱惑。。。 然后很惊喜的发现，沥中的电脑竟然都有音响？！ $8:23$ Contest Start！ T1 是一道简单蛇形矩阵，很快就肝掉了。 然后看了看 T2，好像是模拟分数加减法，感觉约分、通分有点麻烦就先跳过去做 T3 了。 T3 是啥我也忘了，反正 4 分钟就肝掉了。。 继续看 T4，我觉得还是滚远点比较好。继续看 T5，感觉不太可做，就先溜了。 回去 T2 打了一个短除法的 gcd（谁让我不会辗转相除法呢）和 lcm，花了半个小时（其实大多数时间都是在窥屏隔壁玩小恐龙的2333）就肝掉了。 走过去看 T6，我肝！！！一个贪心肝掉了。（Bessie Cow 好评） 继续滚回去 T4，觉得很难。这种题目以前的话，超时超掉一半分也算正常。然后继续苦思冥想。。。 然后就想到了桶排序的思想，艰难地打了出来。。 长呼一口气，颓颓小恐龙！（我可能是忘记了还有 T5 没做 颓着颓着就和隔壁沥北小学的老哥谈上了。 最后在 $9:52$ 的时候非常暴力地怒切掉了 T5！做完了！ 于是开始快乐地玩耍… 发现电脑的 CPU 是 Intel Core i3-6100 CPU @ 3.70GHz。。海星吧 然后右边的老哥又画了一个 九勾玉轮回眼 和 三勾玉写轮眼！ 哦对，小恐龙还颓到了 $1750$！ 比赛结束前十分钟非常紧张，一遍又一遍地检查文件读写有没有错、该开的 long long 有没有开······快疯了。 个人感觉难度 T1 &lt; T2 &lt; T3 &lt; T5 &lt; T4 &lt; T6 ，估分 $50 + 50 + 50 + 40 + 40 + 40$ 吧。 分数到 Day 2 下午就出了，$50 + 50 + 50 + 50 + 40 + 40 = 280$，$rank 35$，非常满意！ 那么，$NHOI 2019$ 再见，$NHOI 2020$ 你好！","link":"/2019/06/02/NHOI-2019/"},{"title":"AT1157 2015","text":"题目链接https://www.luogu.org/problemnew/show/AT1157 题解这题还是比较简单的，考的就是 把十进制数字转成二进制数字 以及 判断数字是否回文。 判断回文最简单的方法就是：把一个字符串翻转后，判断是否还等于原字符串。如果等于，就是回文。不等于就不是回文。 核心代码如下： 12345678910111213141516// a 和 b 都是字符串，N 是输入的数while (N){ if (N % 2 == 0) a += '0'; else a += '1'; N /= 2;}b = a;reverse(b.begin(), b.end());// 接下来判断两个字符串是否相等，然后输出即可","link":"/2019/07/24/at1157/"},{"title":"at2001","text":"","link":"/2019/06/08/at2001/"},{"title":"AT2412 最大の和","text":"题目链接https://www.luogu.org/problemnew/show/AT2412 题解其实是一道很简单的题，个人感觉难度 普及-，就是一道前缀和题目。 不知道前缀和的话可以看这里 前缀和 - OI Wiki。 用 b 数组作为前缀和数组，然后算 b 中 最大的长度为 k 的区间的和。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int a[100001], b[100001];int main(){ int n, k, maxx = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } b[1] = a[1]; for (int i = 2; i &lt;= n; i++) { b[i] = b[i-1] + a[i]; } for (int i = k; i &lt;= n; i++) { if (b[i] - b[i-k] &gt; maxx) maxx = b[i] - b[i-k]; } cout &lt;&lt; maxx &lt;&lt; endl; return 0;}","link":"/2019/05/18/at2412/"},{"title":"CF1148A Another One Bites The Dust","text":"题目链接https://www.luogu.org/problemnew/show/CF1148A 题解这道题其实很简单，意思就是拼一个要求 相邻字符不一样 的字符串，而且要越长越好。 $a$ 就是 a 字符的数量，$b$ 就是 b 字符的数量，$c$ 就是 ab 字符串的数量。 由于 ab 是合规的字符串，先把 $c$ 个 ab 全部拼起来。所以答案至少也会有 $c*2$。 然后我们继续把剩下单独的 a 和 b 拼起来，也就是一个 a 一个 b 地拼。先用 temp 加上 min(a, b)，然后答案再加上 $temp*2$。因为最多只可能拼 min(a, b) 对 ab，剩下的只有落单的一个 a 或者 b。 到这里就完了吗？其实没有。 我们拿一个样例 2 1 2 来试一下： 首先把 $c$ 个 ab 全部拼起来，$ans += 2*2$ 继续把剩下单独的 a 和 b 拼起来，$ans += min(a, b) * 2$ 也就是 $ans += 1*2$ 到这里，$ans$ 就是 $6$ 了。但是正确的答案是 $8$，为什么呢？ 我们来看看，先把 $2$ 个 ab 拼起来，这个字符串就是 abab 了。 然后再加 $1$ 个 a、$1$ 个 b 拼起来，字符串又加了 ab 也就是 ababab 了。 到了这里，$a$ 变量其实还剩下 1 个，$b$ 变量倒是没了。在 ababab 后面其实是还可以加一个 a 的，我们只需要加一个特判就可以解决这个问题。 123456789101112131415161718192021222324252627// [CF1148A Another One Bites The Dust] https://www.luogu.org/problemnew/show/CF1148A#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ ios::sync_with_stdio(false); // 加快速度 long long a, b, c, ans = 0; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; long long temp = min(a, b); ans += c*2; ans += temp * 2; a -= temp; b -= temp; if (a || b) // 特判 ans++; cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/06/07/cf1148a/"},{"title":"CF545D Queue","text":"题目链接https://www.luogu.org/problemnew/show/CF545D 题解还算简单的一道贪心题目。 当然也可以用队列来做。 题目就是 Queue 首先排序，然后用一个 time 变量记录所用总时间。如果这个人的等待的时间小于他被服务的时间，ans 就加 1 并且 time 加上这个人的服务时间。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int a[100005];long long ans, tim;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } sort(a, a+n); for (int i = 0; i &lt; n; i++) { if (tim &lt;= a[i]) { tim += a[i]; ans++; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/05/11/cf545d/"},{"title":"LeetCode 237. 删除链表中的节点","text":"题目链接https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 题解这题是真**的妙啊！ 要求删除链表里的一个结点，但是只给了要删除的结点。 一般来说都是要找到被删除结点的前一个结点才能够进行删除的，但是这题没有。 只能另辟蹊径了。 我们无法删除这个结点，但是我们可不可以删除这个结点的下一个结点，然后用这个结点代替它呢？ 试试。 现有一个链表 —— head = [4, 5, 1, 9]，删除值为 5 的结点。输入：head = [4, 5, 1, 9], node = 5 按照刚才的思路，把值为 5 的第二个结点变成第三个结点，也就是把它的值和 next 指针都改为第三个结点的值和 next 指针。 这样一来这个链表就变成 4, 1, 1, 9 了，然后删除第三个结点即可。 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: void deleteNode(ListNode* node) { int val = node-&gt;next-&gt;val; ListNode* next = node-&gt;next-&gt;next; delete node-&gt;next; node-&gt;val = val; node-&gt;next = next; // 其实也可以不删除结点，直接跳过它 // 这样的话两行代码就搞定了 // but 不推荐这样做 /* node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; */ }};","link":"/2019/07/17/lc237/"},{"title":"LeetCode 292. Nim 游戏","text":"题目链接LeetCode 292. Nim 游戏 题解其实是一道很简单的找规律啦，我在纸上推了一下就懂了。 $n$ 小于 $3$ 的话，不用说肯定是先手赢，一次就能拿完。 但是如果 $n$ 是 $4$ 的时候，先手无论怎么拿，最后一个都会被后手拿去。 你拿一个，后手拿三个；你拿两个，后手拿两个；你拿三个，后手拿一个。 ok，我们继续来看看，是不是所有 $4$ 的倍数都是这样呢？ 拿 $8$ 举例，不论你拿多少个，对手总是可以把情况变得和 $4$ 块时一样：你拿一个，后手拿三个；你拿两个，后手拿两个；你拿三个，后手拿一个。这样只剩下 $4$ 个了，于是你又输了。 然后再推一下非 $4$ 的倍数的数个石头的情况就可以了。 最后的结论就是：如果 $n$ 是 $4$ 的倍数，先手会输。否则先手赢。 12345678910class Solution {public: bool canWinNim(int n) { if (n % 4 == 0) { return false; } return true; }};","link":"/2019/07/19/lc292/"},{"title":"洛谷 P1162 填涂颜色","text":"题目链接https://www.luogu.org/problemnew/show/P1162 题解这道题有点意思，个人感觉比跳马和迷宫那两题都要难一点。 我觉得 DFS 好写点，于是就用了 DFS。 思路是这样的： 首先，$2$ 不可能出现在方阵边缘。因为闭合圈周围都要有数字 $1$。 所以我们先遍历方阵的四条边，用 DFS 先把闭合圈外面所有的 $0$ 改成 $2$。 这样方阵就会有三种数字：$0$、$1$、$2$。 其中，$0$ 表示在闭合圈内，$1$ 表示是闭合圈的边缘，$2$ 表示在闭合圈外。 比如下面这个样例： 1234560 0 0 0 0 00 0 1 1 1 10 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1 经过如上处理后，就会变成这样： 1234562 2 2 2 2 22 2 1 1 1 12 1 1 0 0 11 1 0 0 0 11 0 0 0 0 11 1 1 1 1 1 所以我们只要这样输出： 如果是 $2$，就输出 $0$ 如果是 $1$，就输出 $1$ 如果是 $0$，就输出 $2$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int n;int a[35][35];const int dx[] {-1, 1, 0, 0}, dy[] {0, 0, -1, 1};void dfs(int x, int y);int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; a[i][j]; } } for (int j = 1; j &lt;= n; j++) { if (a[1][j] == 0) { dfs(1, j); } if (a[n][j] == 0) { dfs(n, j); } } for (int i = 1; i &lt;= n; i++) { if (a[i][1] == 0) { dfs(i, 1); } if (a[i][n] == 0) { dfs(i, n); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (a[i][j] == 2) cout &lt;&lt; 0 &lt;&lt; ' '; else if (a[i][j] == 0) cout &lt;&lt; 2 &lt;&lt; ' '; else cout &lt;&lt; 1 &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0;}void dfs(int x, int y){ if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n || a[x][y] != 0) { return; } else { a[x][y] = 2; } for (int i = 0; i &lt; 4; i++) { int tx = x+dx[i]; int ty = y+dy[i]; dfs(tx, ty); }}","link":"/2019/05/04/luogu1162/"},{"title":"洛谷 P1387 最大正方形","text":"题目链接https://www.luogu.org/problemnew/show/P1387 题解我用的是二维前缀和的方法。 首先计算二维前缀和（如果不会就看 OI Wiki 叭，懒得解释了），我们用 $b$ 数组来存前缀和，公式就是 $b_{i,j} = b_{i - 1,j} + b_{i,j - 1} - b_{i - 1,j - 1} + a_{i,j}$。 比如下面这个矩阵： 12340 1 1 11 1 1 00 1 1 01 1 0 1 计算出来的前缀和数组就是： 12340 1 2 31 3 5 61 4 7 82 6 9 11 然后一个一个地枚举正方形就好了，注意枚举的时候要从边长 $2$ 开始枚举，一直到 $min(n, m)$ 结束。 枚举只要判断这个正方形中所有数字的和是不是 棱长*棱长 就行了，如果是，那么说明这是一个可行的解。 那么如何求出这个正方形中所有数字的和呢？一个公式：$b[i][j] - b[i-l][j] - b[i][j-l] + b[i-l][j-l]$ ，其中 $l$ 就是正方形的棱长。 把一种棱长的正方形都枚举完了，那就棱长加一。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[103][103];int b[103][103];int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; a[i][j]; b[i][j] = b[i][j-1] + b[i-1][j] - b[i-1][j-1] + a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cout &lt;&lt; b[i][j] &lt;&lt; ' '; } cout &lt;&lt; endl; } int ans = 1; int l = 2; while (l &lt;= min(n, m)) { for (int i = l; i &lt;= n; i++) { for (int j = l; j &lt;= m; j++) { if (b[i][j] - b[i-l][j] - b[i][j-l] + b[i-l][j-l] == l*l) { ans = max(ans, l); } } } l++; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/20/luogu1387/"},{"title":"洛谷 P1443 马的遍历","text":"题目链接题解","link":"/2019/07/24/luogu1443/"},{"title":"洛谷 P1464 Function","text":"题目链接题解","link":"/2019/07/24/luogu1464/"},{"title":"洛谷 P1605 迷宫","text":"题目链接https://www.luogu.org/problemnew/show/P1605 题解就是一道 DFS，不过坑有点多。 一道 普及- 的题目提交了 3 次才 A 掉，还是太弱了…… 坑点总结： 起点不是 1, 1，而是数据中的 sx, sy。 记得要把起点设为已经访问！！！我就因为这个一直没 AC，看了看题解才意识到这个坑。。。 其它的就没什么了，DFS 打熟练了都会写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;void dfs(int x, int y);int ans, n, m, t;int sx, sy, fx, fy;int a[10][10];bool book[10][10];const int dx[4] {-1, 1, 0, 0}, dy[4] {0, 0, -1, 1};int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy; for (int i = 0; i &lt; t; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; a[x][y] = -1; } book[sx][sy] = 1; dfs(sx, sy); cout &lt;&lt; ans &lt;&lt; endl; return 0;}void dfs(int x, int y){ if (x == fx &amp;&amp; y == fy) { ans++; return; } for (int i = 0; i &lt; 4; i++) { int tx = x+dx[i], ty = y+dy[i]; if (tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m) continue; if (book[tx][ty] == 0 &amp;&amp; a[tx][ty] != -1 &amp;&amp; tx &lt;= n &amp;&amp; tx &gt;= 1) { book[tx][ty] = 1; dfs(tx, ty); book[tx][ty] = 0; } }}","link":"/2019/05/04/luogu1605/"},{"title":"洛谷 P1644 跳马问题","text":"题目链接https://www.luogu.org/problemnew/show/P1644 题解还是不太难的 DFS。 虽说马可以有 8 种跳法，但是这里题目 规定只能往右跳，也就只有 4 个跳法了。 下面代码中的 dx 和 dy 数组就是马的走法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int ans, n, m;const int dx[] { 2, 1, -1, -2}, dy[] { 1, 2, 2, 1};void dfs(int x, int y);int main(){ cin &gt;&gt; n &gt;&gt; m; dfs(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;}void dfs(int x, int y){ if (x == n &amp;&amp; y == m) { ans++; return ; } if (x &lt; 0 || y &lt; 0 || x &gt; n || y &gt; m) return; // 判断是否越界 for (int i = 0; i &lt; 4; i++) { dfs(x + dx[i], y + dy[i]); }}","link":"/2019/05/04/luogu1644/"},{"title":"洛谷 P1724 东风谷早苗","text":"题目链接https://www.luogu.org/problemnew/show/P1724 题解最近在洛谷上发现了这题，突然一阵熟悉的感觉… 原来是 NHOI 模拟赛 里面的题目！！！ 怪不得呢。。。这波操作也是够 6，直接把网上的题目的背景改一下就放进自己的比赛里。。。 哦对了，还有 这题 也是被同样的一波操作给弄进模拟赛了。。 其实很简单的一道题，模拟赛的时候就没拿满分。考完之后重新做一次就 A 了。 刚开始想得很简单，觉得直接模拟就可以了。（弄过来的时候数据范围也没写一写，导致了我产生这个错误的思路，差评） 后来直接模拟没满分，就改了一个麻烦点的做法。 分类讨论： T &lt; 命令串长度：直接模拟没毛病！ T &gt;= 命令串长度：先模拟一次执行一遍命令串后，x 和 y 会是多少。然后乘 T / 命令串长度 ，如果还有余就再模拟一下。 这样一来，速度就上去了。 还有，其实下面的代码里面其实是可以大大简化的，把模拟命令的那部分写成一个函数的话可以大大减少代码长度。由于懒就没写成函数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;int main(){ std::string s; std::cin &gt;&gt; s; long long T; std::cin &gt;&gt; T; long long x, y, tx, ty; x = y = tx = ty = 0; if (T &lt; s.length()) { for (int i = 0; i &lt; T; i++) { switch (s[i]) { case 'E': x++; break; case 'S': y--; break; case 'W': x--; break; case 'N': y++; break; default: break; } } std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; std::endl; } else { for (int i = 0; i &lt; s.length(); i++) { switch (s[i]) { case 'E': tx++; break; case 'S': ty--; break; case 'W': tx--; break; case 'N': ty++; break; default: break; } } int temp = T / s.length(); x += temp * tx; y += temp * ty; if (T % s.length() != 0) { for (int i = 0; i &lt; T % s.length(); i++) { switch (s[i]) { case 'E': x++; break; case 'S': y--; break; case 'W': x--; break; case 'N': y++; break; default: break; } } } std::cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; std::endl; } return 0;}","link":"/2019/05/27/luogu1724/"},{"title":"洛谷 P1765 手机_NOI导刊2010普及（10）","text":"题目链接题解","link":"/2019/07/24/luogu1765/"},{"title":"洛谷 P1958 上学路线_NOI导刊2009普及（6）","text":"题目链接https://www.luogu.org/problemnew/show/P1958 题解dp DFS 都可以吧。 flag 是标记可不可以通行。 由于只能往东和北走，所以一个地方的走法数量就是它 西（左）边走法之和 加 南（下）边走法之和。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int a, b, n, ans;bool flag[50][50];int dp[50][50]; int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; int x, y; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x &gt;&gt; y; flag[x][y] = true; } dp[1][1] = 1; for (int i = 1; i &lt;= a; i++) { for (int j = 1; j &lt;= b; j++) { if (i == 1 &amp;&amp; j == 1 || flag[i][j] == true) continue; dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } cout &lt;&lt; dp[a][b] &lt;&lt; endl; return 0;}","link":"/2019/06/01/luogu1958/"},{"title":"洛谷 P1969 积木大赛","text":"题目链接https://www.luogu.org/problemnew/solution/P1969 题解now 就是当前高度，ans 就是答案。 now 就是当前高度，ans 就是答案。 首先 now = ans = a[0] 就是怎么样最少至少都会操作 a[0] 次。 然后一个一个看，如果大于 now，ans += a[i] - now 也就是增加操作次数，now = a[i] 更新当前高度。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;long long n, now, ans;long long a[1000000];int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } now = ans = a[0]; for (int i = 1; i &lt; n; i++) { if (a[i] &gt; now) { ans += a[i] - now; } now = a[i]; } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","link":"/2019/06/01/luogu1969/"},{"title":"洛谷 P2615 神奇的幻方","text":"题目链接https://www.luogu.org/problemnew/show/P2615 题解其实很简单嘛，模拟就好啦。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std;int a[45][45] = { 0 };int main(){ int n; int k, prevX, prevY; cin &gt;&gt; n; a[1][n/2+1] = 1; // 首先将 1 放在第一行中间 k = 1; prevX = 1, prevY = n/2+1; k++; while (k &lt;= n*n) { if (prevX == 1 &amp;&amp; prevY != n) { a[prevX = n][++prevY] = k++; } else if (prevY == n &amp;&amp; prevX != 1) { a[--prevX][prevY = 1] = k++; } else if (prevX == 1 &amp;&amp; prevY == n) { a[++prevX][prevY] = k++; } else if (prevX != 1 &amp;&amp; prevY != n) { if (a[prevX-1][prevY+1] == 0) { a[--prevX][++prevY] = k++; } else { a[++prevX][prevY] = k++; } } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cout &lt;&lt; a[i][j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0;}","link":"/2019/06/01/luogu2615/"},{"title":"洛谷 P2799 国王的魔镜","text":"题目链接https://www.luogu.org/problemnew/show/P2799 题解利用 增加的那部分是反的 这个规律，每次把字符串分成两半，分别记作 left 和 right。然后反转其中的一个，再对比一下是不是一样的，直到不一样了为止。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main(){ string s; cin &gt;&gt; s; int ans = s.length(); while (s.length() &gt; 1) { string left = s.substr(0, s.length()/2); string right = s.substr(s.length()/2, s.length()-1); reverse(left.begin(), left.end()); // cout &lt;&lt; \"left=\" &lt;&lt; left &lt;&lt; \" right=\" &lt;&lt; right &lt;&lt; endl; if (left != right) break; s = left; ans /= 2; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/06/01/luogu2799/"},{"title":"洛谷 P3984 高兴的津津","text":"题目链接https://www.luogu.org/problemnew/show/P3984 题解很简单的啦。 被 NHOI 一顿神操作给弄进了模拟赛，一模一样的。。。 sum：累计开心的天数 sta：上一次开始开心的时候 首先 sum = T，sta = a[0]。 如果上次开心还没结束，a[i] 就来了，sum 就加上 a[i] 减去 sta。 否则就 sum + T，sta = a[i]。 拿样例试一下： 123 51 2 10 ok，现在循环没开始，T 是 5，sum = T，sta = a[0]。 循环开始了，i=1，a[i] 是 2，sta 是 1，2 &lt; 1 + 5 这个条件成立，所以 sum += 2 - 1，sta = 2。 i=2，a[i] 是 10，sta 是 2，10 &lt; 2 + 5 这个条件不成立，所以 sum += 5，sta = a[i]。 最后输出 sum 即可。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int N, T, sum = 0, sta = 0; cin &gt;&gt; N &gt;&gt; T; int a[200002]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; sum = T; sta = a[0]; for (int i = 1; i &lt; N; i++) { if (a[i] &lt; sta + T) { sum += a[i] - sta; sta = a[i]; } else { sum += T; sta = a[i]; } } cout &lt;&lt; sum &lt;&lt; endl; return 0;}","link":"/2019/05/27/luogu3984/"},{"title":"洛谷 P4305 [JLOI2011]不重复数字","text":"题目链接https://www.luogu.org/problemnew/show/P4305 题解一看题目里面 去重 我就想到了桶排序，不过这道题不是完全的桶排序，只是用到 桶 但是不用 排序。 虽然数字比较大，但是不用遍历桶数组，速度也不是问题。 其实很简单，开一个 bool 类型的桶数组（不需要 int），然后如果有出现的数字就标 true，否则 false。 最后输出，如果桶里面这个数是 true，就直接输出然后标 false。如果是 false 就不输出。这样就可以去重了。 （后来发现题解里也有一个思路一样的，不过他的代码要比我的更优秀点。） 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool bucket[10000005];int a[50005];int main(){ int T; scanf(\"%d\", &amp;T); while (T --&gt; 0) { int n; scanf(\"%d\", &amp;n); // 下面一行其实是可以不用的，看到题解才恍然大悟：bucket 数组在输出的时候已经被全部标成 0 了！ memset(bucket, 0, sizeof(bucket)); // memset(a, 0, sizeof(a)); // 无必要 for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;a[i]); bucket[a[i]] = 1; } for (int i = 0; i &lt; n; i++) { if (bucket[a[i]] == 1) { printf(\"%d \", a[i]); bucket[a[i]] = 0; } } putchar('\\n'); } return 0;}","link":"/2019/06/01/luogu4305/"},{"title":"洛谷 P4431 [COCI2017-2018#2] Košnja","text":"题目链接https://www.luogu.org/problemnew/show/P4431 题解看上去就很简单，实际上更简单。 刚刚看的时候，觉得一个搜索就 OK 了。 然后又转念一想，又发现了一个规律。 答案就是 (min(n, m)-1)*2。 也就是 (行和列中较小的那个数-1)*2，手推一下就好了。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main(){ int k; scanf(\"%d\", &amp;k); while (k--) { int n, m; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", (min(n, m)-1)*2); } return 0;}","link":"/2019/06/01/luogu4431/"}],"tags":[{"name":"游记","slug":"游记","link":"/tags/游记/"},{"name":"NHOI","slug":"NHOI","link":"/tags/NHOI/"},{"name":"回文判断","slug":"回文判断","link":"/tags/回文判断/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"找规律","slug":"找规律","link":"/tags/找规律/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"连通块","slug":"连通块","link":"/tags/连通块/"},{"name":"二维前缀和","slug":"二维前缀和","link":"/tags/二维前缀和/"},{"name":"周期","slug":"周期","link":"/tags/周期/"},{"name":"递推","slug":"递推","link":"/tags/递推/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"桶排序思想","slug":"桶排序思想","link":"/tags/桶排序思想/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"}],"categories":[{"name":"游记","slug":"游记","link":"/categories/游记/"},{"name":"题解","slug":"题解","link":"/categories/题解/"}]}